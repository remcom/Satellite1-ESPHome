globals:
  # Stores the power mode from USB-PD contract (0 for <9V, 2 for >=9V)
  - id: tas2780_power_mode
    type: uint8_t
    restore_value: no
    initial_value: '0'
  # Tracks whether TAS2780 is currently active
  - id: tas2780_active
    type: bool
    restore_value: no
    initial_value: 'false'

audio_dac:
  # Define both DACs
  - platform: tas2780
    id: speaker_dac_tas2780
    address: 0x3F

  - platform: pcm5122
    id: speaker_dac_pcm5122
    address: 0x4D

  # Define the DAC switcher
  - platform: dac_switcher
    id: dac_switcher_main
    tas2780: speaker_dac_tas2780
    pcm5122: speaker_dac_pcm5122

# API actions for switching between DACs
api:
  actions:
    - action: switch_to_speaker
      then:
        - dac_switcher.select_tas2780:
            id: dac_switcher_main

    - action: switch_to_lineout
      then:
        - dac_switcher.select_pcm5122:
            id: dac_switcher_main

select:
  - platform: template
    name: Speaker channel output
    id: tas_mode_select
    icon: "mdi:speaker-multiple"
    options:
      - "Mono (Left + Right)"
      - "Left Channel Only"
      - "Right Channel Only"
    initial_option: "Mono (Left + Right)"
    entity_category: config
    optimistic: true
    restore_value: true
    on_value:
      - tas2780.update_config:
          channel: !lambda |-
            auto index = id(tas_mode_select).active_index();
            if (index.has_value()){
              return index.value();
            }
            ESP_LOGI("main", "No channel selected");
            return 0;

binary_sensor:
  - platform: gpio
    id: line_out_sensor
    pin:
      pcm5122: speaker_dac_pcm5122
      pin: 4
      inverted: false
    name: "Line-Out Connected"
    icon: "mdi:audio-input-stereo-minijack"
    filters:
      - delayed_on: 200ms
      - delayed_off: 200ms

    on_press:
      # Cable inserted - switch to line-out DAC
      - dac_switcher.select_pcm5122:
          id: dac_switcher_main
      - lambda: id(jack_plugged_recently) = true;
      - script.execute: control_leds
      - delay: 200ms
      - script.execute:
          id: play_sound
          priority: false
          sound_file: "jack_connected_sound"
      - delay: 800ms
      - lambda: id(jack_plugged_recently) = false;
      - script.execute: control_leds

    on_release:
      # Cable removed - switch back to speaker DAC
      - dac_switcher.select_tas2780:
          id: dac_switcher_main
      - lambda: id(jack_unplugged_recently) = true;
      - script.execute: control_leds
      - delay: 200ms
      - script.execute:
          id: play_sound
          priority: false
          sound_file: "jack_disconnected_sound"
      - delay: 800ms
      - lambda: id(jack_unplugged_recently) = false;
      - script.execute: control_leds

fusb302b:
  id: pd_fusb302b
  irq_pin: GPIO1
  request_voltage: 20
  on_power_ready:
    then:
      - logger.log:
          format: "PD contract got accepted: %s"
          args: ['id(pd_fusb302b).contract.c_str()']

      - text_sensor.template.publish:
          id: pd_state_text
          state: !lambda 'return id(pd_fusb302b).contract;'
      - lambda: |-
          // Store power mode based on USB-PD contract voltage
          if (id(pd_fusb302b).contract_voltage >= 9) {
            id(tas2780_power_mode) = 2;
          } else {
            id(tas2780_power_mode) = 0;
          }
      - tas2780.activate:
          mode: !lambda return id(tas2780_power_mode);
      - lambda: id(tas2780_active) = true;

speaker:
  - platform: i2s_audio
    id: i2s_audio_speaker
    sample_rate: 48000
    i2s_dout_pin: GPIO9
    bits_per_sample: 32bit
    i2s_audio_id: i2s_shared
    dac_type: external
    channel: stereo
    timeout: never
    buffer_duration: 100ms
    audio_dac: dac_switcher_main  # Using DAC switcher for TAS2780/PCM5122 selection

  # Virtual speakers to combine the announcement and media streams together into one output
  - platform: mixer
    id: mixing_speaker
    output_speaker: i2s_audio_speaker
    num_channels: 2
    task_stack_in_psram: true
    source_speakers:
      - id: announcement_mixing_input
        timeout: never
      - id: media_mixing_input
        timeout: never

  # Virtual speakers to resample each pipelines' audio, if necessary, as the mixer speaker requires the same sample rate
  - platform: resampler
    id: announcement_resampling_speaker
    output_speaker: announcement_mixing_input
    sample_rate: 48000
    bits_per_sample: 16
  - platform: resampler
    id: media_resampling_speaker
    output_speaker: media_mixing_input
    sample_rate: 48000
    bits_per_sample: 16

sendspin:
  id: sendspin_hub
  task_stack_in_psram: true
  kalman_process_error: 0.01

media_source:
  - platform: sendspin
    id: sendspin_source
  - platform: http_request
    id: http_source
    buffer_size: 500000
  - platform: file
    id: file_source
    files:
      - id: center_button_press_sound
        file: ${center_button_press_sound_file}
      - id: center_button_double_press_sound
        file: ${center_button_double_press_sound_file}
      - id: center_button_triple_press_sound
        file: ${center_button_triple_press_sound_file}
      - id: center_button_long_press_sound
        file: ${center_button_long_press_sound_file}
      - id: factory_reset_initiated_sound
        file: ${factory_reset_initiated_sound_file}
      - id: factory_reset_cancelled_sound
        file: ${factory_reset_cancelled_sound_file}
      - id: factory_reset_confirmed_sound
        file: ${factory_reset_confirmed_sound_file}
      - id: jack_connected_sound
        file: ${jack_connected_sound_file}
      - id: jack_disconnected_sound
        file: ${jack_disconnected_sound_file}
      - id: mute_switch_on_sound
        file: ${mute_switch_on_sound_file}
      - id: mute_switch_off_sound
        file: ${mute_switch_off_sound_file}
      - id: timer_finished_sound
        file: ${timer_finished_sound_file}
      - id: wake_word_triggered_sound
        file: ${wake_word_triggered_sound_file}
      - id: error_cloud_expired
        file: ${error_cloud_expired_sound_file}

media_player:
  - platform: sendspin
    id: sendspin_group_media_player
  - platform: speaker_source
    id: external_media_player
    name: Media Player
    volume_increment: 0.05
    volume_min: 0.1
    volume_max: 1.
    sources:
      - file_source
      - http_source
      - sendspin_source
    announcement_speaker: announcement_resampling_speaker
    media_speaker: media_resampling_speaker
    announcement_pipeline:
      format: FLAC     # FLAC is the least processor intensive codec
      num_channels: 1  # Stereo audio is unnecessary for announcements
      sample_rate: 48000
    media_pipeline:
      format: FLAC     # FLAC is the least processor intensive codec
      num_channels: 2
      sample_rate: 48000

    on_mute:
      - script.execute: control_leds
    on_unmute:
      - script.execute: control_leds
    on_volume:
      - script.execute: control_leds
    # Apply audio ducking when an announcement starts
    on_announcement:
      - mixer_speaker.apply_ducking:
          id: media_mixing_input
          decibel_reduction: 20
          duration: 0.0s
    # Restore audio ducking when not actively playing announcements or running voice assistant
    on_state:
      # Ensure TAS2780 is active when audio is playing
      - if:
          condition:
            or:
              - media_player.is_playing: external_media_player
              - media_player.is_announcing: external_media_player
          then:
            - script.execute: tas2780_ensure_active
      - if:
          condition:
            and:
              - switch.is_off: timer_ringing
              - not:
                  voice_assistant.is_running:
              - not:
                  media_player.is_announcing: external_media_player
          then:
            - mixer_speaker.apply_ducking:
                id: media_mixing_input
                decibel_reduction: 0
                duration: 1.0s

script:
  # Script executed when we want to play sounds on the device.
  - id: play_sound
    parameters:
      priority: bool
      sound_file: string
    then:
      - if:
          condition:
            lambda: return priority;
          then:
            - media_player.stop:
                id: external_media_player
                announcement: true
      - lambda: |-
          if ( (id(external_media_player).state != media_player::MediaPlayerState::MEDIA_PLAYER_STATE_ANNOUNCING ) || priority) {
            id(external_media_player)
              ->make_call()
              .set_media_url("file://" + sound_file)
              .set_announcement(true)
              .perform();
          }

  # Script to increased/decreased volume
  - id: control_volume
    mode: restart
    parameters:
      increase_volume: bool  # True: Increase volume / False: Decrease volume.
    then:
      - delay: 16ms
      - if:
          condition:
            lambda: return increase_volume;
          then:
            - media_player.volume_up:
                id: external_media_player
          else:
            - media_player.volume_down:
                id: external_media_player
      - script.execute: control_leds
      - delay: 2s
      - lambda: id(volume_buttons_touched) = false;
      - script.execute: control_leds

  # Script to activate TAS2780 when audio playback starts
  - id: tas2780_ensure_active
    mode: single
    then:
      - if:
          condition:
            lambda: return !id(tas2780_active);
          then:
            - logger.log:
                format: "Activating TAS2780 with power mode %d"
                args: ['id(tas2780_power_mode)']
            - tas2780.activate:
                mode: !lambda return id(tas2780_power_mode);
            - lambda: id(tas2780_active) = true;

sensor:
  - platform: sendspin
    type: kalman_error
    name: "Kalman Error"  # Time sync filter uncertainty estimate

  - platform: sendspin
    type: audible_syncs
    name: "Audible Syncs"  # Major sync events that are audible

# Sendspin: only needed for text metadata
text_sensor:
  - platform: sendspin
    type: title
    name: Track Title

  - platform: sendspin
    type: artist
    name: Artist

  - platform: sendspin
    type: album
    name: Album

  - platform: sendspin
    type: year
    name: Year

  - platform: sendspin
    type: track
    name: Track Number

interval:
  - interval: 30s
    then:
      - if:
          condition:
            - lambda: return id(tas2780_active);
            - for:
                time: 60s
                condition:
                  or:
                    - media_player.is_idle: external_media_player
                    - media_player.is_paused: external_media_player
          then:
            - logger.log: "Deactivating TAS2780 due to 10 minutes of idle"
            - tas2780.deactivate:
            - lambda: id(tas2780_active) = false;
