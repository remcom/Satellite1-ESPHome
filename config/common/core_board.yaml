esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  cpu_frequency: 240MHz
  flash_size: 16MB
  framework:
    type: esp-idf
    version: recommended
    sdkconfig_options:
      CONFIG_ESP32S3_DATA_CACHE_64KB: "y"
      CONFIG_ESP32S3_DATA_CACHE_LINE_64B: "y"
      CONFIG_ESP32S3_INSTRUCTION_CACHE_32KB: "y"

      # Moves instructions and read only data from flash into PSRAM on boot.
      # Both enabled allows instructions to execute while a flash operation is in progress without needing to be placed in IRAM.
      # Considerably speeds up mWW at the cost of using more PSRAM.
      CONFIG_SPIRAM_RODATA: "y"
      CONFIG_SPIRAM_FETCH_INSTRUCTIONS: "y"

      CONFIG_BT_ALLOCATION_FROM_SPIRAM_FIRST: "y"
      CONFIG_BT_BLE_DYNAMIC_ENV_MEMORY: "y"

      CONFIG_MBEDTLS_EXTERNAL_MEM_ALLOC: "y"
      CONFIG_MBEDTLS_SSL_PROTO_TLS1_3: "y"  # TLS1.3 support isn't enabled by default in IDF 5.1.5

psram:
  mode: octal
  speed: 80MHz
  ignore_not_found: false

network:
  enable_ipv6: true

i2c:
  - id: i2c_0
    sda: GPIO5
    scl: GPIO6
    frequency: 400kHz
    scan: True

spi:
  - id: spi_0
    clk_pin:  GPIO12
    mosi_pin: GPIO11
    miso_pin: GPIO13
    interface: SPI2

i2s_audio:
  - id: i2s_shared
    i2s_lrclk_pin: GPIO07
    i2s_bclk_pin: GPIO08
    i2s_mclk_pin: GPIO16
    access_mode: duplex
    i2s_mode: secondary
    use_legacy: false

sensor:
  - platform: wifi_signal 
    name: Wi-Fi Signal RSSI
    id: wifi_signal_db
    update_interval: 60s
    state_class: measurement
    entity_category: "diagnostic"
    disabled_by_default: True
  - platform: uptime
    name: Uptime Seconds
    id: uptime_seconds
    internal: true
    update_interval: 60s
    entity_category: diagnostic
  - platform: internal_temperature
    name: Internal Temperature
    update_interval: 60s
    state_class: measurement
    device_class: temperature
    disabled_by_default: True

text_sensor:
  - platform: template
    name: Uptime
    icon: mdi:clock-start
    entity_category: diagnostic
    update_interval: 60s
    disabled_by_default: True
    lambda: |-
      // Check if uptime sensor has valid data
      if (isnan(id(uptime_seconds).state) || id(uptime_seconds).state < 0) {
        return {"Starting..."};
      }
      
      int seconds = (int)id(uptime_seconds).state;
      int days = seconds / 86400;
      int hours = (seconds % 86400) / 3600;
      int minutes = (seconds % 3600) / 60;
      
      if (days > 0) {
        return to_string(days) + "d " + to_string(hours) + "h";
      } else if (hours > 0) {
        return to_string(hours) + "h " + to_string(minutes) + "m";
      } else {
        return to_string(minutes) + "m";
      }
